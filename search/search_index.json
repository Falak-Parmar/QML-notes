{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Quantum Machine Learning <p> A gentle, structured walk through quantum ideas, machine learning models, and the mathematics beneath them. </p> <p> IT401 \u00b7 Course Notes Kashyap Sureshchandra Patel \u00b7 Falak Naresh Parmar </p> <p> Enter Notes </p> <p> Courtesy of Prof. Manjunath V. Joshi at DAU </p>"},{"location":"bloch_sphere/","title":"Bloch Sphere Representation","text":"<p>The Bloch Sphere is a geometric representation of the state space of a single qubit. Every pure state of a qubit corresponds to a point on the surface of the sphere.</p>"},{"location":"bloch_sphere/#1-geometric-representation","title":"1. Geometric Representation","text":"<p>Any single-qubit pure state \\(|\\psi\\rangle\\) can be written as:</p> <p>[ |\\psi\\rangle = \\cos\\left(\\frac{\\theta}{2}\\right)|0\\rangle + e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)|1\\rangle ] where: - \\(0 \\le \\theta \\le \\pi\\) is the polar angle (angle with the Z-axis). - \\(0 \\le \\phi &lt; 2\\pi\\) is the azimuthal angle (angle with the X-axis).</p> <p>Coordinate Mapping</p> <p>Note that while the qubit state is a vector in 2-dimensional complex Hilbert space \\(\\mathbb{C}^2\\), the Bloch Sphere is a representation in 3-dimensional real space \\(\\mathbb{R}^3\\). The factor of \\(\\theta/2\\) in the state vector \\(|\\psi\\rangle\\) is crucial because a full rotation of \\(2\\pi\\) around the Bloch Sphere corresponds to a change in the state vector by a factor of \\(-1\\) (a phase of \\(\\pi\\)).</p>"},{"location":"bloch_sphere/#11-bloch-vector","title":"1.1 Bloch Vector","text":"<p>The coordinates of the state on the Bloch sphere are given by the vector \\(\\vec{r}\\): [ \\vec{r} = \\begin{bmatrix} \\sin\\theta \\cos\\phi \\ \\sin\\theta \\sin\\phi \\ \\cos\\theta \\end{bmatrix} ] - For pure states, \\(|\\vec{r}| = 1\\) (point on the surface). - For mixed states, \\(|\\vec{r}| &lt; 1\\) (point inside the sphere).</p>"},{"location":"bloch_sphere/#2-visualization","title":"2. Visualization","text":"|0&gt; (Z+) |1&gt; (Z-) |+&gt; (X+) |\u2212&gt; (X-) |+i&gt; (Y+) |\u2212i&gt; (Y-) |\u03c8&gt; \u03b8 \u03c6"},{"location":"bloch_sphere/#3-axis-correspondence","title":"3. Axis Correspondence","text":"<p>The standard measurement bases map to the principal axes of the sphere:</p> Axis Basis States Notation Z ${ 0\\rangle, X ${ +\\rangle, Y ${ +i\\rangle,"},{"location":"bloch_sphere/#31-probability-interpretation","title":"3.1 Probability Interpretation","text":"<p>The polar angle \\(\\theta\\) determines the probability of measuring \\(|0\\rangle\\) or \\(|1\\rangle\\): - \\(P(0) = \\cos^2\\left(\\frac{\\theta}{2}\\right)\\) - \\(P(1) = \\sin^2\\left(\\frac{\\theta}{2}\\right)\\)</p> <p>The azimuthal angle \\(\\phi\\) represents the relative phase between \\(|0\\rangle\\) and \\(|1\\rangle\\).</p>"},{"location":"bloch_sphere/#4-rotations-on-the-bloch-sphere","title":"4. Rotations on the Bloch Sphere","text":"<p>Single-qubit unitary operations can be viewed as rotations of the Bloch vector around various axes.</p>"},{"location":"bloch_sphere/#41-rotation-gates","title":"4.1 Rotation Gates","text":"<ul> <li>\\(R_z(\\lambda)\\): Rotation around the Z-axis. This changes the azimuthal angle \\(\\phi\\) but keeps the probability (polar angle \\(\\theta\\)) constant.</li> <li>\\(R_x(\\theta)\\): Rotation around the X-axis.</li> <li>\\(R_y(\\theta)\\): Rotation around the Y-axis.</li> </ul> <p>Unitary Matrices</p> <p>Any single-qubit unitary \\(U\\) can be decomposed into rotations: [ U = e^{i\\alpha} R_z(\\beta) R_y(\\gamma) R_z(\\delta) ] This means all single-qubit operations can be visualized as a sequence of movements on the surface of the Bloch Sphere.</p>"},{"location":"course_content/","title":"IT401 \u2013 Quantum Machine Learning","text":""},{"location":"course_content/#course-content","title":"Course Content","text":""},{"location":"course_content/#overview","title":"Overview","text":"<p>This course introduces the principles of Quantum Machine Learning (QML), combining quantum computing concepts with modern machine learning techniques.</p>"},{"location":"course_content/#topics-covered","title":"Topics Covered","text":"<ul> <li>Difference between Classical Machine Learning and Quantum Machine Learning</li> <li>Introduction to Quantum Applications</li> </ul>"},{"location":"course_content/#mathematical-foundations","title":"Mathematical Foundations","text":"<ul> <li>Vector Spaces</li> <li>Tensor Products</li> <li>Qubits</li> </ul>"},{"location":"course_content/#quantum-mechanical-principles","title":"Quantum Mechanical Principles","text":"<ul> <li>Superposition</li> <li>Entanglement</li> <li>Interference</li> </ul>"},{"location":"course_content/#quantum-computing-basics","title":"Quantum Computing Basics","text":"<ul> <li>Quantum Gates</li> <li>Quantum Circuits</li> <li>Density Matrix Representation</li> </ul>"},{"location":"course_content/#quantum-algorithms","title":"Quantum Algorithms","text":"<ul> <li>Variational Quantum Circuits (VQC)</li> <li>Grover\u2019s Search Algorithm</li> <li>Quantum Fourier Transform (QFT)</li> <li>Quantum Eigensolver</li> <li>Quantum Approximate Optimization Algorithm (QAOA)</li> <li>Variational Quantum Algorithms</li> </ul>"},{"location":"course_content/#quantum-data-encoding","title":"Quantum Data Encoding","text":"<ul> <li>Basis Encoding</li> <li>Amplitude Encoding</li> <li>Angle Encoding</li> <li>Higher-Order Encoding</li> </ul>"},{"location":"course_content/#measurement-hardware","title":"Measurement &amp; Hardware","text":"<ul> <li>Quantum Measurement</li> <li>Noisy Intermediate-Scale Quantum (NISQ) Computing</li> </ul>"},{"location":"course_content/#quantum-machine-learning-models","title":"Quantum Machine Learning Models","text":"<ul> <li>Quantum Support Vector Machine (QSVM)</li> <li>Quantum k-Means Clustering</li> <li>Quantum Neural Networks (QNN)</li> </ul>"},{"location":"course_content/#quantumclassical-hybrid-models","title":"Quantum\u2013Classical Hybrid Models","text":"<ul> <li>Hybrid Classification</li> <li>Hybrid Time Series Analysis</li> <li>Hybrid Super-Resolution</li> </ul>"},{"location":"entanglement/","title":"Quantum Entanglement","text":"<p>Entanglement is a purely quantum phenomenon where the states of two or more particles are linked such that the state of one cannot be described independently of the others, even when separated by large distances.</p>"},{"location":"entanglement/#1-bell-states","title":"1. Bell States","text":"<p>The Bell states (or EPR pairs) are four specific maximally entangled two-qubit states.</p>"},{"location":"entanglement/#11-the-four-bell-states","title":"1.1 The Four Bell States","text":"\\[ |\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}, \\quad |\\Phi^-\\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}} \\] \\[ |\\Psi^+\\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}, \\quad |\\Psi^-\\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}} \\]"},{"location":"entanglement/#2-entanglement-vs-independence","title":"2. Entanglement vs Independence","text":"<p>A two-qubit state \\(|\\psi\\rangle\\) is separable (not entangled) if it can be written as a tensor product of two single-qubit states:</p> \\[ |\\psi\\rangle = |\\psi_1\\rangle \\otimes |\\psi_2\\rangle \\] <p>If a state cannot be written this way, it is entangled.</p>"},{"location":"entanglement/#3-creating-a-bell-state","title":"3. Creating a Bell State","text":"<p>A Bell state can be created using a combination of a Hadamard gate and a CNOT gate.</p> <ol> <li>Start with \\(|00\\rangle\\).</li> <li>Apply \\(H\\) to the first qubit:    \\(|00\\rangle \\rightarrow \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} \\otimes |0\\rangle = \\frac{|00\\rangle + |10\\rangle}{\\sqrt{2}}\\)</li> <li>Apply \\(CNOT\\) with the first qubit as control and second as target:    \\(\\frac{|00\\rangle + |10\\rangle}{\\sqrt{2}} \\xrightarrow{\\text{CNOT}} \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}} = |\\Phi^+\\rangle\\)</li> </ol>"},{"location":"entanglement/#31-circuit-diagram-ascii","title":"3.1 Circuit Diagram (ASCII)","text":"<pre><code>q0: \u2500\u2500H\u2500\u2500\u2500\u25cf\u2500\u2500\n          \u2502\nq1: \u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\n</code></pre>"},{"location":"entanglement/#4-significance-in-qml","title":"4. Significance in QML","text":"<p>Entanglement is a resource that allows quantum models to capture complex correlations between features that would be difficult for classical models to represent efficiently. It contributes to the expressibility of Variational Quantum Circuits (VQCs).</p>"},{"location":"math_prerequisites/","title":"IT401 \u2013 Quantum Machine Learning","text":""},{"location":"math_prerequisites/#math-prerequisites","title":"Math Prerequisites","text":"<p>This document summarizes the mathematical background required for Quantum Machine Learning.</p>"},{"location":"math_prerequisites/#1-probability-theory","title":"1. Probability Theory","text":""},{"location":"math_prerequisites/#11-relative-frequency-definition","title":"1.1 Relative Frequency Definition","text":"<p>The probability of an event is defined as the limit of its relative frequency over repeated trials:</p> \\[ P(A) = \\lim_{n \\to \\infty} \\frac{n_A}{n} \\] <p>where: - \\(n_A\\) is the number of times event \\(A\\) occurs - \\(n\\) is the total number of trials</p>"},{"location":"math_prerequisites/#12-classical-definition","title":"1.2 Classical Definition","text":"<p>For a finite sample space with equally likely outcomes:</p> \\[ P(A) = \\frac{\\text{Number of favorable outcomes}}{\\text{Total number of possible outcomes}} \\]"},{"location":"math_prerequisites/#13-random-variable","title":"1.3 Random Variable","text":"<p>A random variable is a function:</p> \\[ X : \\Omega \\rightarrow \\mathbb{R} \\] <p>It can be: - Discrete - Continuous</p>"},{"location":"math_prerequisites/#14-expectation","title":"1.4 Expectation","text":"<p>The expectation (mean) of a random variable represents its average value.</p> <p>Discrete case: [ E[X] = \\sum_x x \\, P(X = x) ]</p> <p>Continuous case: [ E[X] = \\int_{-\\infty}^{\\infty} x f_X(x)\\, dx ]</p> <p>Interpretation: Expectation is a probability-weighted average and represents: - Long-run average outcome - Average loss or reward in machine learning - Expected observable in quantum systems</p>"},{"location":"math_prerequisites/#2-linear-algebra","title":"2. Linear Algebra","text":""},{"location":"math_prerequisites/#21-symmetric-matrix","title":"2.1 Symmetric Matrix","text":"<p>A matrix \\(A\\) is symmetric if:</p> \\[ A = A^\\top \\] <p>Properties: - All eigenvalues are real - Eigenvectors corresponding to distinct eigenvalues are orthogonal - Always diagonalizable using an orthogonal matrix</p>"},{"location":"math_prerequisites/#22-eigenvalues-and-eigenvectors","title":"2.2 Eigenvalues and Eigenvectors","text":"<p>Procedure: 1. Compute the characteristic equation:    $$    \\det(A - \\lambda I) = 0    $$ 2. Solve for eigenvalues \\( \\lambda \\) 3. Solve:    $$    (A - \\lambda I)v = 0    $$ 4. Normalize eigenvectors if required</p> <p>Important Properties: - Sum of eigenvalues:   $$   \\sum_i \\lambda_i = \\text{tr}(A)   $$ - Product of eigenvalues:   $$   \\prod_i \\lambda_i = \\det(A)   $$</p>"},{"location":"math_prerequisites/#example-eigenvalues-and-eigenvectors-of-a-hermitian-matrix","title":"Example: Eigenvalues and Eigenvectors of a Hermitian Matrix","text":"<p>Given the Hermitian matrix \\(A\\):</p> \\[ A = \\begin{bmatrix} 2 &amp; 1-i \\\\ 1+i &amp; 3 \\end{bmatrix} \\] <ol> <li>Characteristic Equation:    $$    \\det(A - \\lambda I) = (2-\\lambda)(3-\\lambda) - (1-i)(1+i) = \\lambda^2 - 5\\lambda + 4 = 0    $$</li> <li>Eigenvalues: \\((\\lambda-4)(\\lambda-1) = 0 \\implies \\lambda_1 = 4, \\lambda_2 = 1\\).</li> <li>Eigenvectors:</li> <li>For \\(\\lambda_1 = 4\\): \\(v_1 = \\begin{bmatrix} 1-i \\\\ 2 \\end{bmatrix}\\), Normalized: \\(\\hat{v}_1 = \\frac{1}{\\sqrt{6}} \\begin{bmatrix} 1-i \\\\ 2 \\end{bmatrix}\\)</li> <li>For \\(\\lambda_2 = 1\\): \\(v_2 = \\begin{bmatrix} -(1-i) \\\\ 1 \\end{bmatrix}\\), Normalized: \\(\\hat{v}_2 = \\frac{1}{\\sqrt{3}} \\begin{bmatrix} i-1 \\\\ 1 \\end{bmatrix}\\)</li> </ol>"},{"location":"math_prerequisites/#23-covariance-matrix","title":"2.3 Covariance Matrix","text":"<p>For a random vector \\(X \\in \\mathbb{R}^d\\):</p> \\[ \\Sigma = \\text{Cov}(X) = E[(X - E[X])(X - E[X])^\\top] \\] <p>Properties: - Symmetric - Positive semi-definite - Diagonal entries \u2192 variances - Off-diagonal entries \u2192 covariances</p>"},{"location":"math_prerequisites/#example-calculating-covariance-matrix","title":"Example: Calculating Covariance Matrix","text":"<p>Consider a dataset with observations: \\((1, 2, 1), (2, 3, 2), (3, 5, 4)\\). - Means: \\(\\mu_X = 2, \\mu_Y = 10/3, \\mu_Z = 7/3\\). - Covariance Matrix:   $$   \\Sigma = \\begin{bmatrix} 2/3 &amp; 1 &amp; 1 \\ 1 &amp; 14/9 &amp; 14/9 \\ 1 &amp; 14/9 &amp; 14/9 \\end{bmatrix}   $$   (Calculated using \\(\\Sigma = \\frac{1}{n} X_c^\\top X_c\\) where \\(X_c\\) is the centered data matrix).</p>"},{"location":"math_prerequisites/#24-matrix-diagonalization","title":"2.4 Matrix Diagonalization","text":"<p>Eigendecomposition: $$ A = Q \\Lambda Q^{-1} $$</p> <p>Singular Value Decomposition (SVD): $$ A = U \\Sigma V^\\top $$</p>"},{"location":"math_prerequisites/#25-types-of-matrices","title":"2.5 Types of Matrices","text":"<ul> <li>Hermitian Matrix</li> <li>\\(A = A^\\dagger\\)</li> <li>Real eigenvalues</li> <li> <p>Orthogonal eigenvectors</p> </li> <li> <p>Unitary Matrix</p> </li> <li>\\(U^\\dagger U = I\\)</li> <li> <p>Eigenvalues lie on the unit circle</p> </li> <li> <p>Orthogonal Matrix</p> </li> <li>\\(Q^\\top Q = I\\)</li> <li> <p>Preserves lengths and angles</p> </li> <li> <p>Orthonormal Matrix</p> </li> <li> <p>Columns are unit vectors and mutually perpendicular</p> </li> <li> <p>Rotation Matrix   $$   R(\\theta) =   \\begin{bmatrix}   \\cos \\theta &amp; -\\sin \\theta \\   \\sin \\theta &amp; \\cos \\theta   \\end{bmatrix}   $$</p> </li> </ul>"},{"location":"math_prerequisites/#example-eigenvalues-of-a-unitary-matrix","title":"Example: Eigenvalues of a Unitary Matrix","text":"<p>Given the Unitary matrix \\(A\\): $$ A = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; i \\ i &amp; 1 \\end{bmatrix} $$ The eigenvalues are \\(\\lambda_{1,2} = \\frac{1 \\mp i}{\\sqrt{2}} = e^{\\mp i\\pi/4}\\), which lie on the unit circle (\\(|\\lambda| = 1\\)).</p>"},{"location":"math_prerequisites/#26-example-hadamard-matrix","title":"2.6 Example: Hadamard Matrix","text":"<p>The Hadamard matrix is a real, orthogonal, and unitary matrix commonly used in quantum computing. $$ H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \\end{bmatrix} $$ It maps the computational basis states to superposition states: - \\(H|0\\rangle = |+\\rangle\\) - \\(H|1\\rangle = |-\\rangle\\)</p>"},{"location":"measurement_pauli/","title":"Projective Measurement and Pauli Operators","text":"<p>Measurement is the process by which we extract information from a quantum system. Pauli operators are fundamental operators used to describe operations and measurements on qubits.</p>"},{"location":"measurement_pauli/#1-projective-measurement","title":"1. Projective Measurement","text":"<p>Measurement is performed in an orthonormal basis \\(\\{|x_i\\rangle\\}\\) of the Hilbert space. If the system is in state \\(|\\psi\\rangle = \\sum_i c_i |x_i\\rangle\\), measurement causes the state to collapse to one of the basis vectors.</p>"},{"location":"measurement_pauli/#11-born-rule","title":"1.1 Born Rule","text":"<p>The probability of obtaining outcome \\(x_i\\) is: [ P(x_i) = |\\langle x_i|\\psi\\rangle|^2 = |c_i|^2 ] The total probability sums to 1: \\(\\sum_i P(x_i) = 1\\).</p> <p>After measurement with outcome \\(x_i\\), the state becomes \\(|x_i\\rangle\\).</p>"},{"location":"measurement_pauli/#2-pauli-operators","title":"2. Pauli Operators","text":"<p>Pauli operators are both Hermitian and Unitary. Their eigenvalues are always \\(\\pm 1\\), and their eigenvectors form an orthonormal basis.</p>"},{"location":"measurement_pauli/#21-pauli-z-operator-sigma_z","title":"2.1 Pauli Z Operator (\\(\\sigma_z\\))","text":"<p>Identifies phase flips. [ \\sigma_z = \\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \\end{bmatrix} = |0\\rangle\\langle 0| - |1\\rangle\\langle 1| ] - Eigenvalues: \\(\\lambda = \\pm 1\\) - Eigenvectors: \\(|0\\rangle, |1\\rangle\\)</p>"},{"location":"measurement_pauli/#22-pauli-x-operator-sigma_x","title":"2.2 Pauli X Operator (\\(\\sigma_x\\))","text":"<p>Performs a bit flip (\\(|0\\rangle \\leftrightarrow |1\\rangle\\)). [ \\sigma_x = \\begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\end{bmatrix} = |0\\rangle\\langle 1| + |1\\rangle\\langle 0| ] - Eigenvalues: \\(\\lambda = \\pm 1\\) - Eigenvectors:   - \\(|+\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\) for \\(\\lambda = 1\\)   - \\(|-\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)\\) for \\(\\lambda = -1\\)</p>"},{"location":"measurement_pauli/#23-pauli-y-operator-sigma_y","title":"2.3 Pauli Y Operator (\\(\\sigma_y\\))","text":"<p>Performs a combined bit and phase flip. [ \\sigma_y = \\begin{bmatrix} 0 &amp; -i \\ i &amp; 0 \\end{bmatrix} = -i|0\\rangle\\langle 1| + i|1\\rangle\\langle 0| ] - Eigenvalues: \\(\\lambda = \\pm 1\\) - Eigenvectors:   - \\(|+i\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + i|1\\rangle)\\) for \\(\\lambda = 1\\)   - \\(|-i\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - i|1\\rangle)\\) for \\(\\lambda = -1\\)</p>"},{"location":"measurement_pauli/#3-summary-of-pauli-actions","title":"3. Summary of Pauli Actions","text":"Gate Main Action Pauli X Bit flip: $ Pauli Y Bit + phase flip Pauli Z Phase flip: $"},{"location":"measurement_pauli/#4-global-phase","title":"4. Global Phase","text":"<p>A global phase factor \\(e^{i\\theta}\\) does not change physical predictions. [ |\\psi\\rangle \\sim e^{i\\theta} |\\psi\\rangle ] Measurement probabilities and expectation values remain unchanged under global phase.</p>"},{"location":"quantum_circuits/","title":"Quantum Circuits and Basic Gates","text":"<p>A quantum circuit is a sequence of unitary operations (gates) applied to qubits, followed by measurements to extract information.</p>"},{"location":"quantum_circuits/#1-quantum-circuit-representation","title":"1. Quantum Circuit Representation","text":"<p>Quantum programs are represented as circuits where: - Horizontal lines represent qubits. - Blocks represent gates. - Time flows from left to right.</p> <p>Unlike classical circuits, all quantum gates (except measurement) must be unitary and reversible.</p>"},{"location":"quantum_circuits/#2-single-qubit-gates","title":"2. Single Qubit Gates","text":"<p>These gates act on a single qubit at a time.</p>"},{"location":"quantum_circuits/#21-pauli-gates-x-y-z","title":"2.1 Pauli Gates (X, Y, Z)","text":"<p>(See Pauli Operators for detailed matrix forms) - X Gate: Bit flip (\\(|0\\rangle \\leftrightarrow |1\\rangle\\)). - Y Gate: Combined bit and phase flip. - Z Gate: Phase flip (\\(|1\\rangle \\rightarrow -|1\\rangle\\)).</p>"},{"location":"quantum_circuits/#22-hadamard-gate-h","title":"2.2 Hadamard Gate (\\(H\\))","text":"<p>The Hadamard gate is critical for creating superposition.</p> \\[ H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{bmatrix} \\] <p>Action:</p> <ul> <li>\\(H|0\\rangle = |+\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\)</li> <li>\\(H|1\\rangle = |-\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\)</li> </ul>"},{"location":"quantum_circuits/#23-phase-s-gate","title":"2.3 Phase (S) Gate","text":"<p>Apply a phase of \\(i\\) (90 degrees) to the \\(|1\\rangle\\) state. [ S = \\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; i \\end{bmatrix} ]</p>"},{"location":"quantum_circuits/#3-multiple-qubit-gates","title":"3. Multiple Qubit Gates","text":"<p>These gates perform operations on two or more qubits, enabling entanglement.</p>"},{"location":"quantum_circuits/#31-controlled-not-cnot-gate","title":"3.1 Controlled-NOT (CNOT) Gate","text":"<p>The CNOT gate has two inputs: a control qubit and a target qubit. - If the control qubit is \\(|1\\rangle\\), it flips the target qubit. - If the control qubit is \\(|0\\rangle\\), nothing happens.</p> <p>Matrix Form:</p> \\[ \\text{CNOT} = \\begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; 0 \\\\  0 &amp; 1 &amp; 0 &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; 1 \\\\  0 &amp; 0 &amp; 1 &amp; 0  \\end{bmatrix} \\] <p>State Mapping:</p> <ul> <li>\\(|00\\rangle \\rightarrow |00\\rangle\\)</li> <li>\\(|01\\rangle \\rightarrow |01\\rangle\\)</li> <li>\\(|10\\rangle \\rightarrow |11\\rangle\\)</li> <li>\\(|11\\rangle \\rightarrow |10\\rangle\\)</li> </ul>"},{"location":"quantum_circuits/#4-reversibility","title":"4. Reversibility","text":"<p>Since all gates are unitary (\\(U^\\dagger U = I\\)), they are inherently reversible. For example: - \\(X \\cdot X = I\\) - \\(H \\cdot H = I\\) - \\(CNOT \\cdot CNOT = I\\) - \\(S^\\dagger \\cdot S = I\\) (where \\(S^\\dagger = T\\))</p>"},{"location":"quantum_fundamentals/","title":"Quantum Computing Fundamentals","text":"<p>This section covers the basic building blocks of quantum information and the mathematical framework used to describe quantum systems.</p>"},{"location":"quantum_fundamentals/#1-tensors","title":"1. Tensors","text":"<p>A tensor is a mathematical object that generalizes scalars (order 0), vectors (order 1), and matrices (order 2) to higher dimensions.</p>"},{"location":"quantum_fundamentals/#11-tensor-product","title":"1.1 Tensor Product","text":"<p>The tensor product combines two vectors or matrices to form a higher-dimensional object, used to describe joint quantum systems.</p> <p>For matrices \\(A\\) and \\(B\\): [ A = \\begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \\end{bmatrix}, \\quad B = \\begin{bmatrix} b_{11} &amp; b_{12} \\ b_{21} &amp; b_{22} \\end{bmatrix} ] The tensor (Kronecker) product is: [ A \\otimes B = \\begin{bmatrix} a_{11}B &amp; a_{12}B \\ a_{21}B &amp; a_{22}B \\end{bmatrix}  ] [ = \\begin{bmatrix}  a_{11}b_{11} &amp; a_{11}b_{12} &amp; a_{12}b_{11} &amp; a_{12}b_{12} \\  a_{11}b_{21} &amp; a_{11}b_{22} &amp; a_{12}b_{21} &amp; a_{12}b_{22} \\  a_{21}b_{11} &amp; a_{21}b_{12} &amp; a_{22}b_{11} &amp; a_{22}b_{12} \\  a_{21}b_{21} &amp; a_{21}b_{22} &amp; a_{22}b_{21} &amp; a_{22}b_{22}  \\end{bmatrix} ]</p>"},{"location":"quantum_fundamentals/#2-hilbert-space","title":"2. Hilbert Space","text":"<p>A Hilbert space is a complete vector space with an inner product. Quantum states are represented as normalized vectors in a complex Hilbert space \\(\\mathcal{H} = \\mathbb{C}^n\\).</p>"},{"location":"quantum_fundamentals/#3-qubit","title":"3. Qubit","text":"<p>A qubit is the basic unit of quantum information. Its state is a unit vector in \\(\\mathbb{C}^2\\): [ |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle ] where \\(\\alpha, \\beta \\in \\mathbb{C}\\) are probability amplitudes.</p>"},{"location":"quantum_fundamentals/#31-normalization-condition","title":"3.1 Normalization Condition","text":"<p>The total probability must be one: [ |\\alpha|^2 + |\\beta|^2 = 1 \\implies \\langle\\psi|\\psi\\rangle = 1 ] This ensures the state vector has unit length.</p>"},{"location":"quantum_fundamentals/#4-dirac-notation","title":"4. Dirac Notation","text":"<p>Quantum states and operators are written using bra-ket notation: - Ket \\(|\\psi\\rangle\\): Represents the state vector in Hilbert space (column vector). - Bra \\(\\langle\\psi|\\): Represents the dual (conjugate transpose) of the ket (row vector).</p>"},{"location":"quantum_fundamentals/#41-inner-product-bra-ket","title":"4.1 Inner Product (Bra-Ket)","text":"<p>[ \\langle\\phi|\\psi\\rangle = \\text{scalar complex number} ] Represents the overlap or probability amplitude between two states.</p>"},{"location":"quantum_fundamentals/#42-outer-product-ket-bra","title":"4.2 Outer Product (Ket-Bra)","text":"\\[ |\\psi\\rangle\\langle\\phi| = \\text{linear operator (matrix)} \\]"},{"location":"quantum_fundamentals/#example-bra-ket-and-ket-bra","title":"Example: Bra-Ket and Ket-Bra","text":"<p>Let \\(|a\\rangle = \\begin{bmatrix} a_0 \\\\ a_1 \\end{bmatrix}\\) and \\(|b\\rangle = \\begin{bmatrix} b_0 \\\\ b_1 \\end{bmatrix}\\). - Inner Product: \\(\\langle a|b\\rangle = a_0^* b_0 + a_1^* b_1\\) - Outer Product: \\(|a\\rangle\\langle b| = \\begin{bmatrix} a_0 b_0^* &amp; a_0 b_1^* \\\\ a_1 b_0^* &amp; a_1 b_1^* \\end{bmatrix}\\)</p>"},{"location":"quantum_fundamentals/#5-computational-basis","title":"5. Computational Basis","text":"<p>The standard basis for a single qubit is: [ |0\\rangle = \\begin{bmatrix} 1 \\ 0 \\end{bmatrix}, \\quad |1\\rangle = \\begin{bmatrix} 0 \\ 1 \\end{bmatrix} ] For two qubits, the basis is: \\(\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}\\).</p>"},{"location":"quantum_fundamentals/#6-density-matrix","title":"6. Density Matrix","text":"<p>The density matrix \\(\\rho\\) represents the state of a quantum system. [ \\rho = \\sum_k p_k |\\psi_k\\rangle\\langle\\psi_k|, \\quad \\sum_k p_k = 1 ] where \\(p_k\\) are classical probabilities of the system being in state \\(|\\psi_k\\rangle\\).</p>"},{"location":"quantum_fundamentals/#61-pure-vs-mixed-states","title":"6.1 Pure vs Mixed States","text":"<ul> <li>Pure State: \\(\\rho = |\\psi\\rangle\\langle\\psi|\\). Characterized by \\(tr(\\rho^2) = 1\\).</li> <li>Mixed State: A statistical ensemble of pure states. Characterized by \\(tr(\\rho^2) &lt; 1\\).</li> </ul>"},{"location":"quantum_fundamentals/#62-properties","title":"6.2 Properties","text":"<ul> <li>Hermitian: \\(\\rho = \\rho^\\dagger\\)</li> <li>Positive Semidefinite: \\(\\langle\\psi|\\rho|\\psi\\rangle \\geq 0\\)</li> <li>Unit Trace: \\(tr(\\rho) = 1\\)</li> </ul>"}]}